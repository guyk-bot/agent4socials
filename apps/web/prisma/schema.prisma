generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_DIRECT_URL")
}

enum AuthProvider {
  LOCAL
  GOOGLE
}

model User {
  id                 String             @id @default(cuid())
  supabaseId         String?            @unique
  email              String             @unique
  password           String?
  name               String?
  provider           AuthProvider       @default(LOCAL)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  socialAccounts     SocialAccount[]
  posts              Post[]
  automationSettings AutomationSettings?
  brandContext       BrandContext?
}

model BrandContext {
  id                  String   @id @default(cuid())
  userId              String   @unique
  user                User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  targetAudience      String?  // Who you're writing for (demographics, interests)
  toneOfVoice         String?  // e.g. professional, casual, playful
  toneExamples        String?  // Example phrases or posts that match the desired tone
  productDescription  String?  // What you sell or offer
  additionalContext   String?  // Any other info for the AI (brand values, keywords, etc.)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
}

enum Platform {
  INSTAGRAM
  TIKTOK
  YOUTUBE
  FACEBOOK
  TWITTER
  LINKEDIN
}

model SocialAccount {
  id              String   @id @default(cuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  platform        Platform
  username        String
  platformUserId  String   @unique
  profilePicture  String?
  accessToken     String
  refreshToken    String?
  expiresAt       DateTime?
  scopes          String[] @default([])
  status          String   @default("connected")
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  postTargets     PostTarget[]
  importedPosts   ImportedPost[]

  @@unique([userId, platform, platformUserId])
}

model ImportedPost {
  id               String   @id @default(cuid())
  socialAccountId  String
  socialAccount    SocialAccount @relation(fields: [socialAccountId], references: [id], onDelete: Cascade)
  platformPostId  String
  platform        Platform
  content         String?
  thumbnailUrl    String?
  permalinkUrl   String?
  impressions     Int      @default(0)
  interactions    Int      @default(0)
  publishedAt     DateTime
  mediaType       String?  // IMAGE, VIDEO, etc.
  syncedAt        DateTime @default(now())

  @@unique([socialAccountId, platformPostId])
}

model PendingFacebookConnection {
  id          String   @id @default(cuid())
  userId      String
  accessToken String
  pages       Json     // Array<{ id: string, name?: string, picture?: string }>
  expiresAt   DateTime
  createdAt   DateTime @default(now())
}

model PendingInstagramConnection {
  id          String   @id @default(cuid())
  userId      String
  accessToken String
  accounts    Json     // Array<{ id: string, username?: string, profilePicture?: string }>
  expiresAt   DateTime
  createdAt   DateTime @default(now())
}

enum PostStatus {
  DRAFT
  SCHEDULED
  POSTING
  POSTED
  FAILED
}

model Post {
  id                    String     @id @default(cuid())
  userId                String
  user                  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  title                 String?
  content               String?
  contentByPlatform     Json?      // { INSTAGRAM?: string, FACEBOOK?: string, ... }
  mediaByPlatform       Json?      // { INSTAGRAM?: { fileUrl: string; type: string }[], ... }
  commentAutomation     Json?      // { keywords: string[], replyTemplate: string, usePrivateReply?: boolean } when set, enable keyword auto-reply for this post
  status                PostStatus @default(DRAFT)
  scheduledAt           DateTime?
  scheduleDelivery      String?    // 'auto' | 'email_links'; when 'email_links', at scheduled time we send email with links to post manually
  scheduleEmailSentAt   DateTime?  // set when we sent the "post manually" email so we don't send twice
  emailOpenToken        String?    // one-time token for /post/[id]/open?t= so user can open share links without logging in
  emailOpenTokenExpiresAt DateTime?
  postedAt              DateTime?
  createdAt             DateTime   @default(now())
  updatedAt             DateTime   @updatedAt

  media         MediaAsset[]
  targets       PostTarget[]
}

model AutomationSettings {
  id                     String   @id @default(cuid())
  userId                 String   @unique
  user                   User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  dmWelcomeEnabled       Boolean  @default(false)
  dmWelcomeMessage       String?
  dmNewFollowerEnabled   Boolean  @default(false)
  dmNewFollowerMessage   String?  // Not supported by Instagram API; kept for future or other platforms
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt
}

model PostTarget {
  id              String       @id @default(cuid())
  postId          String
  post            Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  platform        Platform
  socialAccountId String
  socialAccount   SocialAccount @relation(fields: [socialAccountId], references: [id], onDelete: Cascade)
  status          PostStatus   @default(SCHEDULED)
  platformPostId  String?
  error           String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@unique([postId, platform, socialAccountId])
}

enum MediaType {
  IMAGE
  VIDEO
}

model MediaAsset {
  id        String    @id @default(cuid())
  postId    String
  post      Post      @relation(fields: [postId], references: [id], onDelete: Cascade)
  fileUrl   String
  type      MediaType
  size      Int?
  duration  Float?
  metadata  Json?
  createdAt DateTime @default(now())
}
